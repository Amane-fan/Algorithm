> 题目链接：https://ac.nowcoder.com/acm/contest/95323/F

> 标签：双指针，前缀和

## 思路：

子数组问题，考虑枚举右，维护左的一般思考方式。

具体来说，我需要枚举右端点，检查有多少左端点满足要求。对于每一个右端点，左端点一定是最左端，且满足子数组内元素种类为2。

当右端点移动的时候，会发现，左端点有单调性，也就是说，**对于下一个右端点而言，其左端点的位置一定大于等于上一个右端点所对应的左端点位置**，因为右端点移动的时候，必然会导致元素种类不降。

因此考虑使用双指针，就可以找到每个右端点，所对应的极小左端点的位置（即区间范围极大）。

那么还剩下一个问题，如何判断该区间内有多少子区间满足要求？

由于区间内元素种类的个数最多为2，考虑将 $x$ 设为 1， 将 $y$ 设为 -1，如此一来，只需要满足该区间和为0即可。

例如：对于区间 $[l,r]$ ，我需要找到一个左端点 $L \in [l,r-1]$ ，满足：$pre[r] = pre[L - 1]$ 。

**转换一下：**找到一个左端点 $L \in [l - 1, r - 2]$ ，满足： $pre[r] = pre[L]$ 。

 规定一个数组 $t[i] = (a[i] = a[i - 1] ? t[i - 1] : -t[i - 1])$ ，这样就能够保证区间内元素个数为2的时候，其中一个全是1，另一个全是-1，对这个数组做前缀和即可 。

注意，当左端点离开区间的时候，需要让 $pre[j-1]$ 数量增加。

## Code:

```c++
void solve() {
    int n;
    cin >> n;
    vector<int> a(n + 1);
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }

    vector<int> t(n + 1);
    vector<int> pre(n + 1);
    t[1] = 1;
    pre[1] = 1;
    for (int i = 2; i <= n; i++) {
        if (a[i] == a[i - 1]) {
            t[i] = t[i - 1];
        } else {
            t[i] = -t[i - 1];
        }
        pre[i] = pre[i - 1] + t[i];
    }


    map<int, int> P;// 前缀和为x的个数
    map<int, int> M;// 某个数出现的次数

    int cnt = 0;// 区间内不同数字的个数
    ll ans = 0;
    for (int i = 1, j = 1; i <= n; i++) {
        if (M[a[i]]++ == 0) cnt++;
        P[pre[i - 1]]++;
        while (cnt > 2) {
            P[pre[j - 1]]--;
            if (--M[a[j]] == 0) cnt--;
            j++;
        }
        ans += P[pre[i]];
    }
    cout << ans << '\n';

}
```

